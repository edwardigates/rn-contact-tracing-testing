{"version":3,"sources":["Vectors.ts"],"names":["Animated","clamp","clamp1","Value","block","create","x","y","createValue","isAdaptable","value","Node","get","vectors","dimension","map","vector","apply","fn","add","sub","dot","multiply","div","divide","min","max","minVec","maxVec","invert","a","set","b","vec"],"mappings":"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","sourcesContent":["import Animated from \"react-native-reanimated\";\n\nimport { clamp as clamp1 } from \"./Math\";\n\nconst { Value, block } = Animated;\ntype Dimension = \"x\" | \"y\";\ntype Fn = (...args: Animated.Adaptable<number>[]) => Animated.Node<number>;\ntype Adaptable = Vector | Animated.Adaptable<number>;\ntype BinArgOp<T extends Adaptable = Adaptable> = [T, T, ...T[]];\n\nexport interface Vector<\n  T extends Animated.Adaptable<number> = Animated.Adaptable<number>\n> {\n  x: T;\n  y: T;\n}\n\nconst create = <T extends Animated.Adaptable<number>>(x: T, y?: T) => ({\n  x,\n  y: y || x,\n});\n\nconst createValue = (x: number, y?: number) =>\n  create(new Value(x), new Value(y || x));\n\nconst isAdaptable = (value: Adaptable): value is Animated.Adaptable<number> =>\n  typeof value === \"number\" ||\n  value instanceof Animated.Node ||\n  value instanceof Animated.Value;\n\nconst get = (vectors: Adaptable[], dimension: Dimension) =>\n  vectors.map((vector) => (isAdaptable(vector) ? vector : vector[dimension]));\n\nconst apply = (fn: Fn, ...vectors: Adaptable[]) => ({\n  x: fn(...get(vectors, \"x\")),\n  y: fn(...get(vectors, \"y\")),\n});\n\nconst add = (...vectors: BinArgOp) => apply(Animated.add, ...vectors);\nconst sub = (...vectors: BinArgOp) => apply(Animated.sub, ...vectors);\nconst dot = (...vectors: BinArgOp) => apply(Animated.multiply, ...vectors);\nconst div = (...vectors: BinArgOp) => apply(Animated.divide, ...vectors);\nconst min = (vector: Vector, value: Animated.Adaptable<number>) =>\n  apply(Animated.min, vector, value);\nconst max = (vector: Vector, value: Animated.Adaptable<number>) =>\n  apply(Animated.max, vector, value);\nconst clamp = (value: Vector, minVec: Vector, maxVec: Vector) =>\n  apply(clamp1, value, minVec, maxVec);\n\nconst invert = (a: Vector) => dot(-1, a);\n\nconst set = (a: Vector<Animated.Value<number>>, b: Adaptable) =>\n  block([\n    Animated.set(a.x, isAdaptable(b) ? b : b.x),\n    Animated.set(a.y, isAdaptable(b) ? b : b.y),\n  ]);\n\nexport const vec = {\n  create,\n  createValue,\n  invert,\n  add,\n  sub,\n  dot,\n  div,\n  multiply: dot,\n  divide: div,\n  set,\n  clamp,\n  apply,\n  min,\n  max,\n};\n"]}